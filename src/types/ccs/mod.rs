
use anyhow::{anyhow, Result};
use ark_ff::{Field};

use self::types::{CCSInstance, CCSWitness};
use super::{r1cs::R1CS, utils::*, Matrix, Multiset}; // For matrix and vector operations

pub mod types;
// todo
// would be neat to parameterize CCS over whether it was natively generated by R1CS, Plonkish, AIR,
// or from scratch
//
// pub enum CCSCompatibility

// Defining the CCS structure.
#[derive(Debug)]
pub struct CCS<F: Field> {
  /// matrix width.
  /// n > l
  n:         usize,
  /// matrix height
  m:         usize,
  /// Todo: what is l?
  l:         usize,
  /// Todo: what is N?
  N:         usize,
  /// Number of matrices
  t:         usize,
  /// Number of multisets and constants
  q:         usize,
  /// Cardinality bound for each element in multiset
  d:         usize,
  /// matrices $M_0,...,M_{t-1}\in \mathbb F^{m\times n}$ with at most $N=\Omega(\max(m,n))$
  /// non-zero entries in total
  matrices:  Vec<Matrix<F>>,
  /// A sequence of $q$ multisets $[S_0,...,S_{q-1}]$.
  /// An element in each multiset is from the domain $[t-1]$.
  /// Cardinality of each multiset at most $d$.
  multisets: Vec<Multiset<usize>>,
  /// a sequence of $q$ constants $[c_0,...,c_{q-1}]$ with $c_i\in \mathbb F$.
  constants: Vec<F>,
}

impl<F: Field> CCS<F> {
  pub fn new(
    // matrix width
    n: usize,
    // matrix height
    m: usize,
    l: usize,
    N: usize,
    // maximum element value for multiset
    t: usize,
    q: usize,
    d: usize,
    matrices: Vec<Matrix<F>>,
    multisets: Vec<Multiset<usize>>,
    constants: Vec<F>,
  ) -> Self {
    // todo: return Err, don't panic
    assert!(n > l);
    assert!(t > 0);
    // todo: move multiset validation into newtype
    assert!(multisets.len() == q);
    for ms in multisets.iter() {
      assert!(ms.len() <= d);
      for &el in ms {
        assert!(el < t);
      }
    }
    assert_eq!(matrices.len(), t);
    assert_eq!(constants.len(), q);

    Self {
      n,
      m,
      l,
      N,
      t,
      q,
      d,
      // todo: how shall we initialize the following
      matrices,
      multisets,
      constants,
    }
  }

  /// Implement the checks based on the equation (2) in the definition
  /// $$\sum\limits_{i=0}^{q-1} c_i\cdot \bigcirc_{j\in S_i}M_j\cdot z=\mathbf{0}$$
  pub fn is_satisfied_by(&self, instance: &CCSInstance<F>, witness: &CCSWitness<F>) -> bool {
    let z = Self::compute_z(&witness.w, &instance.x);

    // ⚠️ read carefully warning ⚠️
    self
      .constants
      .iter()
      .zip(self.multisets.iter())
      .map(|(&c_i, s_i)| {
        // each multiset s_i specifies the indices of matrices
        s_i.iter().map(|&j| &self.matrices[j]).map(|M_j| matrix_vector_prod(M_j, &z))
        // have a collection of vectors, now apply hadamard product
        .reduce(|acc, row| hadamard(&acc, &row))
        .unwrap()
        // have the i'th vector corresponding to s_i, now apply constant
        .into_iter()
        .map(|el| el * c_i).collect::<Vec<_>>()
        // it remains now only to sum all q vectors and check if the result is the zero vector
      })
      .reduce(|acc, row| hadasum(&acc, &row))
      .unwrap()
      .into_iter()
      // we good?
      .all(|el| el.is_zero())
  }

  /// Convert the CCS instance into an R1CS instance
  pub fn to_r1cs(&self) -> Result<R1CS<F>> {
    if self.r1cs_representable() {
      let (A, B, C) =
        (self.matrices[0].clone(), self.matrices[1].clone(), self.matrices[2].clone());
      Ok(R1CS::new(self.n, self.m, self.l, self.N, A, B, C))
    } else {
      Err(anyhow!("not an R1CS representable instance"))
    }
  }

  /// Is this CCS instance R1CS representable? Constants taken from page 4.
  pub fn r1cs_representable(&self) -> bool {
    let S1 = vec![0, 1];
    let S2 = vec![2];
    self.matrices.len() == 3
      && self.t == 3
      && self.q == 2
      && self.d == 2
      && self.multisets == vec![S1, S2]
      && self.constants == [F::one(), -F::one()]
  }

  // /// Convert the CCS instance into an Plonkish instance
  // pub fn to_plonkish(&self) -> Result<Plonkish<F>> {
  //   todo!();
  //   // if self.plonkish_representable() {
  //     // Ok(Plonkish::new())
  //   // } else {
  //     // Err(anyhow!("not a Plonkish representable instance"))
  //   // }
  // }

  /// Is this CCS instance Plonkish representable?
  pub fn plonkish_representable(&self) -> bool {
    todo!()
  }


  // /// Convert the CCS instance into an Plonkish instance
  // pub fn to_air(&self) -> Result<AIR<F>> {
  //   todo!();
  //   // if self.plonkish_representable() {
  //     // Ok(Plonkish::new())
  //   // } else {
  //     // Err(anyhow!("not a Plonkish representable instance"))
  //   // }
  // }
  //   /// Is this CCS instance AIR representable?
  // pub fn air_representable(&self) -> bool {
  //   todo!()
  // }


  /// z = (w, 1, x)
  fn compute_z<'a>(w: &'a [F], x: &'a [F]) -> Vec<F> {
    w.iter().cloned().chain(std::iter::once(F::one())).chain(x.iter().cloned()).collect()
  }
}
