use std::fmt;

use anyhow::anyhow;
use ark_ff::{Field, PrimeField};
use ndarray::{Array, Array2};
use num_bigint::BigUint;
use thiserror::Error;
use typenum::{Cmp, Greater, IsGreater};

use super::{r1cs::R1CS, Matrix, Multiset}; // For matrix and vector operations

// todo
// would be neat to parameterize CCS over whether it was natively generated by R1CS, Plonkish, AIR,
// or from scratch
//
// pub enum CCSCompatibility

#[derive(Debug, Error)]
pub enum CCSError {
  #[error(transparent)]
  Anyhow(#[from] anyhow::Error),
  #[error("Default error: {0}")]
  Default(String),
}

// Defining the CCS structure.
// todo: may want to move some of these usize parameters into type gen
#[derive(Debug)]
pub struct CCS<F: Field> {
  // matrix width
  // n > l
  n:         usize,
  // matrix height
  m:         usize,
  l:         usize,
  N:         usize,
  t:         usize,
  q:         usize,
  d:         usize,
  /// matrices $M_0,...,M_{t-1}\in \mathbb F^{m\times n}$ with at most $N=\Omega(\max(m,n))$
  /// non-zero entries in total
  matrices:  Vec<Matrix<F>>,
  /// A sequence of $q$ multisets $[S_0,...,S_{q-1}]$.
  /// An element in each multiset is from the domain $[t-1]$.
  /// Cardinality of each multiset at most $d$.
  multisets: Vec<Multiset<usize>>,
  /// a sequence of $q$ constants $[c_0,...,c_{q-1}]$ with $c_i\in \mathbb F$.
  constants: Vec<F>,
}

/// A CCS witness consists of a vector $w\in $\mathbb F^{n-l-l}$.
#[derive(Debug)]
pub struct CCSWitness<F: Field> {
  w: Vec<F>,
}

/// A CCS instance consists of public input $x\in \mathbb F^l$.
#[derive(Debug)]
pub struct CCSInstance<F: Field> {
  x: Vec<F>,
}

impl<F: Field> CCS<F> {
  pub fn new(
    // matrix width
    n: usize,
    // matrix height
    m: usize,
    l: usize,
    N: usize,
    // maximum element value for multiset
    t: usize,
    q: usize,
    d: usize,
    matrices: Vec<Matrix<F>>,
    multisets: Vec<Multiset<usize>>,
    constants: Vec<F>,
  ) -> Self {
    assert!(n > l);
    assert!(t > 0);
    // todo: move multiset validation into newtype
    assert!(multisets.len() == q);
    for ms in multisets.iter() {
      assert!(ms.len() <= d);
      for el in ms {
        assert!(el < &t);
      }
    }
    assert_eq!(matrices.len(), t);
    assert_eq!(constants.len(), q);

    Self {
      n,
      m,
      l,
      N,
      t,
      q,
      d,
      // todo: how shall we initialize the following
      matrices,
      multisets,
      constants,
    }
  }

  /// Implement the checks based on the equation (2) in the definition
  /// $$\sum\limits_{i=0}^{q-1} c_i\cdot \bigcirc_{j\in S_i}M_j\cdot z=\mathbf{0}$$
  pub fn is_satisfied_by(&self, instance: &CCSInstance<F>, witness: &CCSWitness<F>) -> bool {
    let z = Self::compute_z(&witness.w, &instance.x);

    // convenience; todo; move to utils
    let dot = |v: &[F], w: &[F]| v.iter().zip(w.iter()).map(|(vi, wi)| *vi * *wi).sum();
    let matrix_vector_prod = |matrix: &Vec<Vec<F>>, vector: &Vec<F>| {
      matrix.iter().map(|row| dot(row, &z)).collect::<Vec<F>>()
    };
    let hadamard = |v1: &Vec<F>, v2: &Vec<F>| {
      v1.iter().zip(v2.iter()).map(|(&v1_i, &v2_i)| v1_i * v2_i).collect()
    };
    let hadasum = |v1: &Vec<F>, v2: &Vec<F>| {
      v1.iter().zip(v2.iter()).map(|(&v1_i, &v2_i)| v1_i + v2_i).collect()
    };

    // ⚠️ read carefully warning ⚠️
    self
      .constants
      .iter()
      .zip(self.multisets.iter())
      .map(|(&c_i, s_i)| {
        // each multiset s_i specifies the indices of matrices
        s_i.iter().map(|&j| &self.matrices[j]).map(|M_j| matrix_vector_prod(M_j, &z))
        // have a collection of vectors, now apply hadamard product
        .reduce(|acc, row| hadamard(&acc, &row))
        .unwrap()
        // have the i'th vector corresponding to s_i, now apply constant
        .into_iter()
        .map(|el| el * c_i).collect::<Vec<_>>()
        // it remains now only to sum all q vectors and check if the result is the zero vector
      })
      .reduce(|acc, row| hadasum(&acc, &row))
      .unwrap()
      .into_iter()
      // we good?
      .all(|el| el.is_zero())
  }

  /// Convert the CCS instance into an R1CS instance
  pub fn to_r1cs(&self) -> Result<R1CS<F>, CCSError> {
    if self.r1cs_representable() {
      let (A, B, C) =
        (self.matrices[0].clone(), self.matrices[1].clone(), self.matrices[2].clone());
      Ok(R1CS::new(self.n, self.m, self.l, self.N, A, B, C))
    } else {
      Err(anyhow!("CCS is not R1CS representable").into())
    }
  }

  /// z = (w, 1, x)
  fn compute_z<'a>(w: &'a [F], x: &'a [F]) -> Vec<F> {
    w.iter().cloned().chain(std::iter::once(F::one())).chain(x.iter().cloned()).collect()
  }

  /// Is this CCS instance R1CS representable?
  pub fn r1cs_representable(&self) -> bool {
    let S1 = vec![0, 1];
    let S2 = vec![2];
    self.matrices.len() == 3
      && self.t == 3
      && self.q == 2
      && self.d == 2
      && self.multisets == vec![S1, S2]
      && self.constants == [F::one(), -F::one()]
  }
}
