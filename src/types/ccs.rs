use std::fmt;

use anyhow::anyhow;
use ark_ff::{Field, PrimeField};
use ndarray::{Array, Array2};
use num_bigint::BigUint;
use thiserror::Error;
use typenum::{Cmp, Greater, IsGreater};

use super::{r1cs::R1CS, Matrix, Multiset}; // For matrix and vector operations

// todo
// would be neat to parameterize CCS over whether it was natively generated by R1CS, Plonkish, AIR,
// or from scratch
//
// pub enum CCSCompatibility

#[derive(Debug, Error)]
pub enum CCSError {
  #[error(transparent)]
  Anyhow(#[from] anyhow::Error),
  #[error("Default error: {0}")]
  Default(String),
}

// Defining the CCS structure.
// todo: may want to move some of these usize parameters into type gen
#[derive(Debug)]
pub struct CCS<F: Field> {
  // matrix width
  n:         usize,
  // matrix height
  m:         usize,
  l:         usize,
  N:         usize,
  t:         usize,
  q:         usize,
  d:         usize,
  /// matrices $M_0,...,M_{t-1}\in \mathbb F^{m\times n}$ with at most $N=\Omega(\max(m,n))$
  /// non-zero entries in total
  matrices:  Vec<Matrix<F>>,
  /// a sequence of $q$ multisets $[S_0,...,S_{q-1}]$ where an element in each multiset is from the
  /// domain $[t-1]$, with cardinality of each multiset at most $d$
  multisets: Vec<Multiset<usize>>,
  /// a sequence of $q$ constants $[c_0,...,c_{q-1}]$ with $c_i\in \mathbb F$.
  constants: Vec<isize>,
}

/// A CCS witness consists of a vector $w\in $\mathbb F^{n-l-l}$.
#[derive(Debug)]
pub struct CCSWitness<F: Field> {
  w: Vec<F>,
}

/// A CCS instance consists of public input $x\in \mathbb F^l$.
#[derive(Debug)]
pub struct CCSInstance<F: Field> {
  x: Vec<F>,
}

impl<F: Field> CCS<F> {
  pub fn new(
    // matrix width
    n: usize,
    // matrix height
    m: usize,
    l: usize,
    N: usize,
    // maximum element value for multiset
    t: usize,
    q: usize,
    d: usize,
    matrices: Vec<Matrix<F>>,
    multisets: Vec<Multiset<usize>>,
    constants: Vec<isize>,
  ) -> Self {
    assert!(n > l);
    assert!(t > 0);
    // todo: move multiset validation into newtype
    assert!(multisets.len() == q);
    for ms in multisets.iter() {
      assert!(ms.len() <= d);
      for el in ms {
        assert!(el < &t);
      }
    }
    assert_eq!(matrices.len(), t);
    assert_eq!(constants.len(), q);

    Self {
      n,
      m,
      l,
      N,
      t,
      q,
      d,
      // todo: how shall we initialize the following
      matrices,
      multisets,
      constants,
    }
  }

  /// Implement the checks based on the equation (2) in the definition
  /// This will involve matrix-vector multiplication, Hadamard product, and summing over the
  pub fn is_satisfied_by(
    &self,
    instance: &CCSInstance<F>,
    witness: &CCSWitness<F>,
  ) -> Result<bool, CCSError> {
    // Compute z = (w, 1, x)
    let z = witness
      .w
      .clone()
      .into_iter()
      .chain(std::iter::once(F::one()).chain(instance.x.clone().into_iter()))
      .collect::<Array<_, _>>();

    // Compute sum from i=0 to q-1 of (ci * sum for each j in Si of Mj * z)
    // let mut vv = Vec::with_capacity(z.len());
    // for c in self.constants {
    //   for ms in self.multisets {
    //     for matrix_j in ms.iter().map(|&idx| self.matrices[idx]) {
    //       // todo
    //       // vv.push(matrix_j * z)
    //     }
    //   }
    // }
    // for v in vv {}

    // let result = (0..self.q)
    //   .map(|i| {
    //     self.constants[i]
    //       * self.multisets[i].iter().fold(F::zero(), |sum, &j| sum + self.matrices[j].dot(&z))
    //   })
    //   .sum::<F>();

    // Check if result is zero
    // Ok(result.is_zero())
    todo!()
  }

  /// Convert the CCS instance into an R1CS instance
  pub fn to_r1cs(&self) -> Result<R1CS<F>, CCSError> {
    if self.r1cs_representable() {
      let (A, B, C) =
        (self.matrices[0].clone(), self.matrices[1].clone(), self.matrices[2].clone());
      Ok(R1CS::new(self.n, self.m, self.l, self.N, A, B, C))
    } else {
      Err(anyhow!("CCS is not R1CS representable").into())
    }
  }

  /// Is this CCS instance R1CS representable?
  pub fn r1cs_representable(&self) -> bool {
    let S1 = vec![0, 1];
    let S2 = vec![2];
    self.matrices.len() == 3
      && self.t == 3
      && self.q == 2
      && self.d == 2
      && self.multisets == vec![S1, S2]
      && self.constants == [1, -1]
  }
}
